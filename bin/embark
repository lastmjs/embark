#!/usr/bin/env node

/* global __dirname __filename process require */

// this script shouldn't use JS syntax or APIs *un*supported by any node
// version >=4.0.0, so unsupported versions from v4.0.0+ will get embarklog
// error output instead of a syntax error or runtime error
// See: https://node.green/

// KEY ASSUMPTION: for a DApp to be valid, from embark's perspective, it must
// have a parsable embark.json file in its top-level directory; if that
// requirement changes in the future (hypothetical example: embark.json info
// can be embedded in package.json under `{"embark": {...}}` vs. stored in a
// separate file) then this script must be revised

function main() {
  // check consistency re: DApp
  // check consistency re: capitalization at start of embarklog messages
  // check time diff 3.1.10 version command and this impl's version command

  // -- setup ------------------------------------------------------------------

  var invokedEmbark = (new EmbarkInvoked(__filename)).handle();

  // findUp search begins in process.cwd() by default, but embark.json could be
  // in a subdir if embark was invoked via `npm run` (which changes cwd to
  // package.json's dir) and the package.json is in a dir above the top-level
  // DApp dir; so start at INIT_CWD if that has been set (by npm, presumably)
  // See: https://docs.npmjs.com/cli/run-script
  var INIT_CWD = process.env.INIT_CWD ? process.env.INIT_CWD : process.cwd();

  var embarkJson = (new EmbarkJson(
    findUp.sync('embark.json', {cwd: INIT_CWD})
  )).handle();

  var dappPath = embarkJson.dirname;
  // set working dir to dir of embark.json, assumed to be DApp's top-level dir
  process.chdir(dappPath);
  process.env.PWD = dappPath;

  var localEmbark;

  var noShim = false;
  if (process.argv.includes('--no-shim')) {
    process.argv.splice(process.argv.indexOf('--no-shim'), 1);
    noShim = true;
  }

  if (!noShim) {
    // try to find a "local" embark in or above but not below dappPath

    // let `dappPath/(([../])*)bin/embark` be a local "containing" embark

    // let `dappPath/(([../])*)node_modules/embark/bin/embark` be a local
    // "installed" embark

    // if a local installed embark is found but is higher in the dir structure
    // than a found local containing embark, containing embark will be
    // preferred

    // weird case: according to the above rule and current implementation, if a
    // local installed embark is found within a local containing embark's own
    // node_modules dir, installed embark will be preferred

    // invoked embark may find itself as local embark, but that is detected
    // prior to cmd execution by comparing `cmdrealpath` props

    // if no local embark is found, or realpath lookup for local embark fails,
    // cmd execution will use invoked embark
    var containingEmbark = (
      new EmbarkLocalContaining(
        findUp.sync('bin/embark', {cwd: dappPath}),
        invokedEmbark
      )
    );

    var installedEmbark = (
      new EmbarkLocalInstalled(
        findUp.sync('node_modules/embark/bin/embark', {cwd: dappPath}),
        invokedEmbark
      )
    );

    containingEmbark.setup(installedEmbark);
    installedEmbark.setup(containingEmbark);

    // per their impls, only one of the two will have pkgDir set
    if (installedEmbark.pkgDir) {
      localEmbark = installedEmbark;
    }
    if (containingEmbark.pkgDir) {
      localEmbark = containingEmbark;
    }

    // look for package.json files from dappDir < ceilingDir that specify
    // embark as a dependency but don't have embark installed in their relative
    // node_modules dirs
    var ceilingDir = localEmbark || null;
    var foundPkgJsonLocal;
    var startDir = dappPath;

    function stop() {
      foundPkgJsonLocal = pkgUp.sync(startDir);
      var foundDir = foundPkgJsonLocal ? path.dirname(foundPkgJsonLocal) : null;
      var _stop = !foundDir
          || foundDir === ceilingDir
          || (ceilingDir && subdir(foundDir, ceilingDir));
      if (!_stop) {
        startDir = path.join(startDir, '..');
      }
      return _stop;
    }

    while (!stop()) {
      (new PkgJsonLocal(foundPkgJsonLocal)).handle();
    }

    localEmbark.log();
  }

  // -- execute ----------------------------------------------------------------

  if (localEmbark
      && localEmbark.cmdpathreal
      && localEmbark.cmdpathreal !== invokedEmbark.cmdpathreal) {
    localEmbark.exec();
  } else {
    invokedEmbark.exec();
  }
}

// == implementation ===========================================================

var embarklog = require('npmlog');
var findUp = require('find-up');
var fs = require('fs');
var path = require('path');
var pkgUp = require('pkg-up');
var semver = require('semver');
var subdir = require('subdir');

embarklog.heading = 'embark';

var _logged = false;
function logged(which) {
  var embarklog_which = embarklog[which];
  return function () {
    _logged = true;
    embarklog_which.apply(embarklog, arguments);
  };
}

function blankLineMaybe(which) {
  if (_logged) {
    console[which]();
  }
}

var isNpmRun = process.env.hasOwnProperty('npm_lifecycle_script');
function blankLineTrailingMaybe(which) {
  if (isNpmRun) {
    console[which]();
  }
}

embarklog.error = logged('error');
embarklog.info = logged('info');
embarklog.warn = logged('warn');

function callSuper(o, m) {
  var args = Array.prototype.slice.call(arguments, 2);
  return Object.getPrototypeOf(o.constructor.prototype)[m].apply(o, args);
}

function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
}

function reportMissing(filepath, loglevel) {
  try {
    // force the exception
    fs.realpathSync(filepath);
  } catch (e) {
    blankLineMaybe(loglevel);
    embarklog[loglevel]('path', e.path);
    embarklog[loglevel]('code', e.code);
    embarklog[loglevel]('errno', e.errno);
    embarklog[loglevel]('syscall', e.syscall);
    embarklog[loglevel](e.code.toLowerCase(), e.message);
  }
}

// -- json files ---------------------------------------------------------------

function Json(filepath) {
  this.filepath = filepath;
  this.dirname = void 0;
  this.json = void 0;
  this.loglevel = 'warn';
  this.realpath = void 0;
}

Json.prototype.handle = function () {
  this.setup();
  this.log();
  return this;
};

Json.prototype.log = function () {
  this.logMissingFile();
  this.logUnparsable();
};

Json.prototype.logMissingFile = function () {
  if (!this.realpath) {
    reportMissing(this.filePath, this.loglevel);
    return true;
  }
};

Json.prototype.logUnparsable = function () {
  if (!this.json) {
    try {
      // force the exception
      require(this.filepath);
    } catch (e) {
      blankLineMaybe(this.loglevel);
      embarklog[this.loglevel]('json', e.message);
    }
    return true;
  }
};

Json.prototype.setDirname = function () {
  if (this.realpath) {
    this.dirname = path.dirname(this.filepath);
  }
};

Json.prototype.setJson = function () {
  if (this.realpath) {
    try {
      this.json = require(this.filepath);
    } catch (e) {}
  }
};

Json.prototype.setRealpath = function () {
  if (this.filepath) {
    try {
      this.realpath = fs.realpathSync(this.filepath);
    } catch (e) {}
  }
};

Json.prototype.setup = function () {
  this.setRealpath();
  this.setDirname();
  this.setJson();
};

// -- embark.json --------------------------------------------------------------

function EmbarkJson(filepath) {
  callSuper(this, 'constructor', filepath);
}
EmbarkJson.prototype = new Json();
EmbarkJson.prototype.constructor = EmbarkJson;

EmbarkJson.prototype.logMissingFile = function () {
  this.loglevel = 'error';
  if (callSuper(this, 'logMissingFile')) {
    embarklog[this.loglevel]('dapp', `Could not locate your DApp's embark.json file`);
    embarklog[this.loglevel](
      'dapp',
      `Make sure a valid embark.json file exists in your DApp's top-level directory`
    );
    blankLineTrailingMaybe(this.loglevel);
    process.exit(1);
  }
};

EmbarkJson.prototype.logUnparsable = function () {
  this.loglevel = 'error';
  if (callSuper(this, 'logUnparsable')) {
    embarklog.error('dapp', `your DApp's embark.json file could not be parsed`);
    blankLineTrailingMaybe(this.loglevel);
    process.exit(1);
  }
};

// -- package.json :: of an embark pkg -----------------------------------------

function PkgJsonEmbark(filepath, kind) {
  callSuper(this, 'constructor', filepath);
  this.kind = kind || '[PkgJsonEmbark KIND]';
  this.nodeRange = void 0;
  this.pkg = void 0;
  this.version = void 0;
}
PkgJsonEmbark.prototype = new Json();
PkgJsonEmbark.prototype.constructor = PkgJsonEmbark;

PkgJsonEmbark.prototype.log = function () {
  callSuper(this, 'log');
  this.logMissingVersion();
  this.logUnsupportedNode();
};

PkgJsonEmbark.prototype.logMissingFile = function () {
  if (callSuper(this, 'logMissingFile')) {
    embarklog[this.loglevel](
      'badpkg',
      `Could not locate ${this.kind} embark's package.json file`
    );
    return true;
  }
};

PkgJsonEmbark.prototype.logMissingVersion = function () {
  if (this.version === '???') {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('path', this.filepath);
    embarklog[this.loglevel](
      'badpkg',
      `No version is specified in ${this.kind} embark's package.json file`
    );
    return true;
  }
};

PkgJsonEmbark.prototype.logUnparsable = function () {
  if (callSuper(this, 'logUnparsable')) {
    embarklog[this.loglevel](
      'badpkg',
      `Could not parse ${this.kind} embark's package.json file`
    );
    return true;
  }
};

PkgJsonEmbark.prototype.logUnsupportedNode = function () {
  var nodeRange = this.nodeRange;
  if (typeof nodeRange === 'undefined') {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('path', this.filepath);
    embarklog[this.loglevel](
      'engine',
      `package.json of ${this.kind} ${this.pkg} embark does not specify %j`,
      {engines: {node: '[semver]'}}
    );
    embarklog[this.loglevel]('engine', 'Defaulting to: %j', {engines: {node: this.nodeRangeDefault}});
    nodeRange = this.nodeRangeDefault;
  }

  try {
    nodeRange = semver.Range(nodeRange).range;
  } catch (e) {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('path', this.filepath);
    embarklog[this.loglevel](
      'engine'
      `package.json of ${this.kind} ${this.pkg} embark does not specify a valid %j`,
      {engines: {node: '[semver]'}}
    );
    embarklog[this.loglevel]('engine', 'Specified: %j', {engines: {node: nodeRange}});
    embarklog[this.loglevel]('engine', 'Defaulting to: %j', {engines: {node: this.defaultNodeRange}});
    nodeRange = this.nodeRangeDefault;
  }

  var procNodeVer = semver.clean(process.version);
  if (!semver.satisfies(procNodeVer, nodeRange)) {
    var loglevel = 'error';
    blankLineMaybe(loglevel);
    embarklog[loglevel]('notsup', 'Unsupported runtime');
    embarklog[loglevel]('notsup', `${this.kind} ${this.pkg} is not compatible with your version of node`);
    embarklog[loglevel]('notsup', 'Required:', nodeRange);
    embarklog[loglevel]('notsup', 'Actual:', procNodeVer);
    blankLineTrailingMaybe(loglevel);
    process.exit(1);
  }
};

// if making a change to the `nodeRangeDefault` value, make sure to manually
// check that it's a valid semver range, otherwise the fallback logic in the
// prototype methods won't be reliable
PkgJsonEmbark.prototype.nodeRangeDefault = semver.Range('>=8.11.3').range;

PkgJsonEmbark.prototype.setNodeRange = function () {
  if (isObject(this.json)
      && this.json.hasOwnProperty('engines')
      && this.json.engines.hasOwnProperty('node')) {
    this.nodeRange = this.json.engines.node;
  }
};

PkgJsonEmbark.prototype.setPkg = function () {
  this.pkg = `embark@${this.version}`;
};

PkgJsonEmbark.prototype.setVersion = function () {
  if (isObject(this.json) && this.json.version) {
    this.version = this.json.version;
  } else {
    this.version = '???';
  }
};

PkgJsonEmbark.prototype.setup = function () {
  callSuper(this, 'setup');
  this.setVersion();
  this.setPkg();
  this.setNodeRange();
};

// -- package.json :: local to DApp --------------------------------------------

// if specifies embark as dev/dep but no embark is installed its dir +
// 'node_modules/embark/bin/embark' then should log warning

function PkgJsonLocal(filepath) {
  callSuper(this, 'constructor', filepath);
}
PkgJsonLocal.prototype = new Json();
PkgJsonLocal.prototype.constructor = PkgJsonLocal;

// -- package.json :: expected by embark install local to DApp -----------------

// package.json -- expect to exist in EmbarkLocalInstalled.pkgDir + '../../'
// and expect to specify embark as dev/dep, otherwise log warnings

function PkgJsonLocalExpected(filepath) {
  callSuper(this, 'constructor', filepath);
}
PkgJsonLocalExpected.prototype = new PkgJsonLocal();
PkgJsonLocalExpected.prototype.constructor = PkgJsonLocalExpected;

// -- bin/embark commands ------------------------------------------------------

function Embark(cmdpath) {
  this.cmdpath = cmdpath;
}

Embark.prototype.exec = function () {
  throw new Error('not implemented');
};

Embark.prototype.handle = function () {
  this.setup();
  this.log();
};

Embark.prototype.log = function () {
  this.pkgJson.log();
};

Embark.prototype.setCmdrealpath = function () {

};

Embark.prototype.setPkgdir = function () {

};

Embark.prototype.setPkgJson = function () {

};

Embark.prototype.setup = function () {
  this.setCmdrealpath();
  this.setPkgDir();
  this.setPkgJson();
};

// -- bin/embark :: invoked ----------------------------------------------------

function EmbarkInvoked(cmdpath) {
  callSuper(this, 'constructor', cmdpath);
}
EmbarkInvoked.prototype = new Embark();
EmbarkInvoked.prototype.constructor = EmbarkInvoked;

EmbarkInvoked.prototype.exec = function () {
  var Cmd = require('../cmd/cmd');
  var cli = new Cmd();
  cli.process(process.argv);
};

// -- bin/embark :: local ------------------------------------------------------

function EmbarkLocal(cmdpath, invokedEmbark) {
  callSuper(this, 'constructor', cmdpath);
  this.invokedEmbark = invokedEmbark;
}
EmbarkLocal.prototype = new Embark();
EmbarkLocal.prototype.constructor = EmbarkLocal;

EmbarkLocal.prototype.exec = function () {
  process.argv[1] = this.cmdpath;
  blankLineMaybe('info');
  embarklog.info('vers', this.invokedEmbark.pkgJson.version);
  embarklog.info('path', this.invokedEmbark.cmdpath);
  embarklog.info('vers', this.pkgJson.version);
  embarklog.info('path', this.cmdpath);
  embarklog.info('dapp', `Switching from ${this.invokedEmbark.pkgJson.pkg} to ${this.pkgJson.pkg}`);
  embarklog.info();
  require(this.cmdpath);
};

EmbarkLocal.prototype.handle = function () {
  throw new Error('not implemented');
};

EmbarkLocal.prototype.setup = function () {
  throw new Error('not implemented');
};

// -- bin/embark :: local containing -------------------------------------------

function EmbarkLocalContaining(cmdpath, invokedEmbark) {
  callSuper(this, 'constructor', cmdpath, invokedEmbark);
}
EmbarkLocalContaining.prototype = new EmbarkLocal();
EmbarkLocalContaining.prototype.constructor = EmbarkLocalContaining;

EmbarkLocalContaining.prototype.setup = function (installedEmbark) {
  //
};

// -- bin/embark :: local installed --------------------------------------------

// this one will setup two pkg Jsons -- one for its own package.json, the other for expected
// locally installed package (relative) to Dapp

function EmbarkLocalInstalled(cmdpath, invokedEmbark) {
  callSuper(this, 'constructor', cmdpath, invokedEmbark);
}
EmbarkLocalInstalled.prototype = new EmbarkLocal();
EmbarkLocalInstalled.prototype.constructor = EmbarkLocalInstalled;

EmbarkLocalInstalled.prototype.log = function () {
  // call both pkg json log
};

EmbarkLocalInstalled.prototype.setup = function (containingEmbark) {
  //
};

// == run ======================================================================

main();
